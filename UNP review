
================================================================================================

SO_RECVBUF    ---   与Win窗口值有关，修改接收缓冲区的大小，等于调整本端滑动窗口的最大值，每个tcp包中窗口值是
					实时变化的，用来告知对端自己的缓冲区还有多少容量，当这个值为0的时候，对端应该停止发送数据。
					
(*)MSS   ---   IP层接收TCP层的最大分节大小，每个传给IP层的TCP PDU都不应当大于这个值(实际负载 = MSS - TCP头)
			在 握手时，这是一个被动选项，用来告知对方，“自己一次能够接收 TCP头+实际负载 ”的最大字节数
			
			应用层将大于 MSS - 20(TCP头) 的数据传给TCP层时，TCP会将数据切分，比如 MSS 是 1460，TCP缓冲区中
			有5000个字节，那么TCP会将5000个字节分成4包(1440,1440,1440,680),然后形成4个TCP PDU(tcp 分段/tcp segment)
			传递给IP层，这4个分段大小为(1460,1460,1460,700)。
			
(*)MTU   ---   链路层接收IP层的最大数据包大小

			IP层在收到TCP传来的不大于MSS的TCP分段后，将数据打上IP头(20个字节)，这个时候务必保证此时的数据
			要比MTU小，因此当MTU确定后(通常有硬件确定，而不是在应用程序中设置)，可以反推出合适的MSS值(MTU - 20),
			这样就能保证IP包不会被链路层分片发送。
			
			如果MSS是1460，而MTU也是1460，那么IP包很可能就是1460+20=1480，此时超过了链路层一个包的最大大小，
			这时候 1480的IP包会被链路层拆成2个(1440(1460+20) + 40(20+20))发送。
			
			以太网的MTU是1500，大于MSS的缺省值1460+20，所以如果不做任何设置，IP包不会分片传输。因为TCP协议栈
			限定了每次丢给IP进行封装的数据包不会大于MSS(默认1460)，所以IP层丢给链路层的IP包也不会超过MTU。

		注：使用wireshark抓包的时候，发送端可能会看到包数据大小大于MSS的现象，这是网卡在其中进行了一些操作，
			我们在接收端看接收数据，会发现实际是接收到了多个包，每个包的数据量都小于MSS。
			
			
			
MSL   ---   IP数据包在英特网中存活的最长时间，主动关闭端在TIME_WAIT状态中持续的时间是这个时间的2倍，即2MSL

HOP LIMIT   ---   IP数据包在英特网中能够跳跃的最大次数，最大为255，255跳的时间不可能超过MSL

RTT   ---   tcp协议分节往返时间，比如三次握手的第一分节发出去到收到第二分节，这之间的时间就是RTT，可以通过
			多次ping来计算一个平均值作为参考。

================================================================================================

SYN 和 ACK 并不始终打包在一起发送的，当且仅当 接收到对端请求 到 处理完对端请求 之间的时间小于200ms时，才会把
这两个流程打包在一起发送，否则会分开发送。比如，三次握手的第一步，接收端如果处理的较慢，那么可能出现先发送
SYN，后发送ACK。
我们抓包时，可以看到[SYN,ACK] [PSH,ACK] 这些都是打包发送，后面的都是前面的“捎带”消息。即以 SYN 和 PSH为主要
消息，顺带把ACK作为刚才收到消息的应答回给对端。

================================================================================================

IP数据包的分片

当IP数据包大于MTU时，IP协议栈将数据包进行分片，注意！是IP协议栈在调用链路层时才知道自己选择的接口
的MTU是多大(接口=网卡~=链路层)，当发现自己将要传给链路层的IP包大于MTU时，IP层自觉地将tcp数据拆开,包装
成相同IP头的数据包，这就是分片。

	(*)注意：分片只会为每个分包增加相同的IP头，不会增加TCP/UDP头，因此分包数据只有一个有TCP/UDP头。

	ipv4 , 发送端 和 路由器都会根据自己的数据链路层对IP包进行分片/再分片，比如主机的MTU是1500，但是，
		   路由线路中某个路由器的MTU却是500，则1480的IP包在到达这个路由器时，因为路由器用的是ipv4协议栈，
		   所以又会被分成更小的片。
		   
	ipv6 ， 不同于ipv4，ipv6只会对自己产生的数据包(对比转发)进行分片。如果某个路由器时ipv6，又MTU
		   是500，则它不会将1480的数据分片，而是直接转发出去。
		   
		   
	（*）注意：ipv4头中有“不分片(DF)”标志位，如果设置了，那么不论产生IP包的主机，还是转发IP包
				的路由器，都不允许分片动作。如果主机的MTU是1500，但是MSS是3000，那么此时报错。
				如果主机MSS是1460，但是某个路由器的MTU是500，此时会报错“ 主机不可达，需要分片
				但是DF被置位”。
	
	
================================================================================================

迷途的重复分组：

分组的迷途，通常是路由器异常导致，如果某个路由器崩溃，或者两个路由器中间的链路断开了，则路由协议
需要一定的时间来找到另外一条可用的通路(路由协议会保存一张表，其中对于网中的节点都有一条最优通路，
一般情况下，各个节点之间都是用最佳通路，如果通路断了，那么路由协议需要重新找一条路，此时使用ICMP
来探进行探路，当找到以后，使用这条路替换原来的路作为最佳路线)。这个时候就可能导致数据包发生路由循环，
比如从A路由器发出，经过B路由器又回到A中，当发现可用路径后，数据包才会跳出这个循环。如果在循环期间且
未到达MSL值之前，发送端由于未收到对端应答而进行了重发，那么网络中就有两份同样的数据(时间戳不一样，其他
都一样)，此时如果超过MSL值，迷途的数据包被丢失，则不会有任何问题。但是如果在MSL值到达之前，可用路由
通路被发现，迷途数据包赶在MSL值之前到达了对端，则对端会有两份一样的数据，此时进入TCP协议栈的重复
数据处理流程。


主动关闭端为什么要进入TIME_WAIT 以及 TIME_WAIT状态为什么要存在？

原因一：上面说到了迷途的数据，主动关闭端发送FIN给对端后，如果立刻终止自己，那么它就无法确认对端时候已经收到
了自己的FIN，因为FIN可能迷途。因此主动关闭端在发送完FIN 后，需要等对端的应答，但是自己此时又不能是
正常工作状态，所以需要在 正常工作 和 已经关闭 之间存在一个临时状态，即TIME_WAIT状态。

原因二：当进入关闭状态时，等于通知内核，当前socket已经被释放，内核可以复用原有的 port，此时如果一个
别的程序使用了这个port，那么它就可能接收到对端发送的迷途数据包(因为这些包还未到达对端，对端就武断
地进入了关闭状态，而另外一个 冒充者 占用了原先的端口)，这是不安全的，等于让另外一个程序有机会处理
其他程序的数据。因此TIME_WAIT状态持续 2MSL，让双端的数据包(迷途的 和 还在赶路的)都能到达对端或者
因为到达MSL时间而被系统丢弃。    

		可见，TIME_WAIT状态是一种		“不接受新会话却依旧处理旧会话的临时状态”
		
		
================================================================================================

bind   ---   指定本端 ip 和 port

================================================================================================

监听套接字 和 已连接套接字 使用相同的端口：

服务端accept返回已连接套接字，已连接套接字和监听套接字使用相同的端口，协议栈不会另行分配端口来
服务已连接套接字，这很容易理解，如果协议栈分配了新端口，那么对端发送的数据将无法到达本端，因为
端口号变了，而对端依旧使用旧的通讯地址(dstip和dstport)。

================================================================================================

（承上）并发服务器中端口号问题：

当并发服务器通过fork生成新的进程来服务客户端时，所有进程都是用相同的ip 和 port，此时协议栈是区分
来自网络的数据将落入那个进程中，毕竟ip 和 port都一样，这个时候就需要以客户端的ip 和 port作为区分
依据，因为客户端每次向服务器请求建立的链接都是用不同的端口号，那么四元组中的客户端port将不一样，
协议栈便以此作为突破点。那么如何区分其他数据呢？比如有服务端fork了2次，有两个服务程序为客户端提供
服务，这个时候就 相当于有 两个连接服务两个客户端，比如客户端端口号为1500 和 1501，那么所有非1500
和1501端口的数据到达服务端后，都将被递送给父进程处理，仅仅1500和1501的数据会被地送给fork的子服务进程

 client_ip:*		--------    server_ip:21 （父进程）
 client_ip:1500     --------    server_ip:21 （子服务进程1）
 client_ip:1501		--------	server_ip:21 （子服务进程2）
 

================================================================================================

(*)MTU发现机制(MSS自调整机制)

上面提到了分片 和 DF位，我们可以利用DF位的特性实现一个路由路径通用MTU值发现的机制：先设置大的MTU
，当某个路由器节点返回“主机不可达，需要分片但是DF置位”错误，发送端就调整MSS值，以控制TCP包的尺寸(数据+20)，
进而控制IP包的尺寸(数据+20+20)，从而保证IP包的尺寸小于MTU而不产生分片现象。


	《UNP》:MSS经常设置成(MTU - TCP头 -IP头)的数值
	
================================================================================================

应用程序数据 和 TCP的发送缓冲区

应用程序即将发送的数据大小是不定的，可能1个字节，也可能10M个字节，通常我们将数据放在一个自定义的
内存中，比如 char buff[1024]。
TCP发送缓冲区是TCP协议栈向内核申请的用来进行程序运算的内存空间，默认是8000多，查看SO_SNDBUF选项可以
获得。

当应用程序通过写入函数 write/writev/send/sendto/...  将自己的数据放入 TCP的 发送缓冲区时，很可能出现
数据量大于缓冲区的可用空间大小(0~8000)，此时，如果socket被设置成阻塞的，那么写入函数将被阻塞住而不能
返回。直到TCP将数据都通过发送缓冲区发送出去为止。比如10M字节要发送，缓冲区中已经有其他应用程序填充
的1000个字节要被发送，那么还剩7000个字节，那么第一次填入 7000个字节，当腾出了1460-20后(大数据包一定
是每次都用MSS值来组装TCP包),立刻再填入1460-20个字节，以此循环发送完10M的数据，write才得以返回，之前
程序会被卡主。

	注：TCP缓冲区中的数据是没有TCP头的，协议栈会从中最多取 MSS-20 个字节来进行数据打包，形成tcp包
		发送出去。

================================================================================================

TCP缓冲区数据何时清除？

当TCP将缓冲区内的数据发送给对端时，对端应该应答ACK以通知发送端自己收到了数据以及收到了多少。当发送端
收到ACK时，才能将刚才发送出去的数据移除出缓冲区，如果收不到ACK，则一定时间后将刚才缓冲区中对应的数据
进行重发。当重发到一定次数和时间后，可以断定对端已经关闭或者发生错误。

	（*）注：当我们发送数据时，会携带一个len值，当前PSH报文的seq + len 便应当是对端ACK 等于的值。
			比如：	[PSH,ACK] Seq = 4 ACK = X Win=X Len=6
					则对端应答应当是
					[ACK]Seq = X ACK = 10 Win=X Len=0
				
				
================================================================================================		
				
《UNP》中对于IP 和 链路层交互的简述：

TCP以MSS大小或者更小的TCP包传递给IP，IP给每个TCP包装上IP头，并按照目的IP地址的值查找路由表以确定
外出的接口(每个网卡有一个IP，每个IP就是一个接口)，然后把数据传递给相应的数据链路层(网卡驱动)，IP
层查询网卡驱动的MTU，如果MTU小于IP包，则IP层先将IP包分片，然后依次交由链路层。
（！）链路层(驱动程序)有一个发送队列，如果队列满了(网卡吞吐量赶不上填充数据的速度)，那么IP层再将
数据填充到链路层时将会出错，IP包将被丢弃，同时IP层告知TCP层数据被丢弃了，这个时候TCP层不会把刚才
发送的数据清出缓冲区，而是过一会重发(这属于网络拥堵)，但是TCP不会把情况告知应用程序，应用程序也
不需要知道这些，只需要知道TCP是不是又腾出空间让自己写数据就好了。

================================================================================================

UDP和TCP 发送缓冲区的异同：

UDP 也有 SO_SNDBUF选项，也指定了一个发送缓冲区大小，这个缓冲区的大小限制了应用层写入的数据的大小，
如果应用层写入超过这个值的数据，那么写入动作失败，报错EMSGSIZE。

和TCP的发送缓冲区不同，这个缓冲区是临时存在的，当数据传递给IP层以后，UDP的这个缓冲区立刻销毁，因为
UDP不需要对数据进行确认和重发， 对方是否收到自己不关心。

对比TCP的发送缓冲区是一块常驻内存区，其中的数据也是慎重移除的。

================================================================================================
		
UDP 相对于 TCP 更容易发生 IP层的分片现象。因为TCP每传给IP的数据最多只能是MSS，而UDP只要SO_SNDBUF够大，
那么它一次传给IP的数据便是无限制的。海量数据直接导致IP包巨大，更容易触及MTU红线。

因此，在UDP编程时，务必控制好应用程序的缓冲区大小，以及通过设置SO_SNDBUF来控制UDP缓冲区的大小。
以此双保险来尽量避免分片的出现。

================================================================================================
		
write udp socket返回代表什么？

（*）调用wirte系列写 UDP socket返回时，代表数据已经进入链路层队列，如果应用层缓冲区大于SO_SNDBUF,那么
多次组装IP并丢入链路层队列中后，函数返回。如果队列已经满了，那么不会像TCP那样自行消化处理，而是
给write调用返回-1，同时报错ENOBUFS
		
================================================================================================
		
大端 小端 助记方法：大端 和 小端 表示多字节的那一端存储在内存的其实位置。

大小端仅仅针对 多字节数值。比如自定义的通讯协议中，username占用了4个字节，又它被约定成大端数据，
那么在处理报文时，先顺序读取4个字节，如果本地机器是小端机器，那么存储时要先进行大端到小端的
转换再存储。否则不需要转换直接存储即可。

================================================================================================
		
读/写 字节流套接字(tcp)

read/wirte 会指定想要	读出/写入 的数据量，但是如果 接收缓冲区数据很少/发送缓冲区可用空间很少，则
往往返回值不等于 想要操作的数据量。 因此我们需要循环 read/write 以使总的操作数据量达到我们 传入
的预期值。		
	ps： 仅在 socket为 非阻塞的时候才这样，阻塞时会一致阻塞到满足条件。
	

================================================================================================
		
下属三种场景会 触发RST：
1）connet一个对端，但是对端port上的服务没启动
2）TCP协议栈想取消一个已有链接，这里可以扩展出很多场景
3）本端接收到一个不存在链接上的tcp包

================================================================================================
		
每个TCP”监听“套接字都维护两个队列：未完成连接的队列 ，已完成连接的队列

当客户端向服务端发送SYN时，服务端收到SYN并在未完成队列中创建一条数据。当三次握手完成时，此条数据
被放到已完成队列的”尾部“。

当服务端调用accept时，会从已完成队列的首部取出一条数据，然后作为已连接套接字反馈给应用程序。
通过循环调用accept来把所有的已连接套接字都反馈给应用程序。

（*）至此，应用程序可以把这些已连接套接字都注册到 select 遍历的队列中，从而实现一次监控多个已连接套接字是否可读。

如果监听套接字是阻塞状态，那么accept在已连接队列为空时会阻塞住。

如果未完成队列+已完成队列 = backlog，那么服务端将忽略后续到达的SYN，而不是发送一个RST，原因在于
队列的满状态极有可能是暂时状态，很快就会恢复，这个时候服务器只要等待客户端的重发即可。

================================================================================================

已完成队列中的套接字是否处于未激活状态？

答案是否定的。
已完成队列中的套接字都是可用的套接字，只是应用程序需要调用accept取挨个获取，因此在调用accept之前，
网络上的数据就已经进入这些已连接套接字的接收缓冲区了。

================================================================================================

已完成套接字队列中的套接字是否已经具备套接字描述符了？

不是，套接字描述符的分配正是 accept 函数的任务。它向内核申请可用的描述符用来和套接字绑定。

accept 返回描述符的同时，可通过2,3参数反馈对端的地址信息

================================================================================================

再次强调文件描述符的概念

多个进程都打开同一个文件，获得各自的文件描述符，任何一个进程关闭自己的描述符，都相当于对文件系统
中的文件引用计数-1，当且仅当计数为0，文件的管理结构才会被移出内核的文件系统。

因此在子进程中关闭监听套接字 和 在父进程中关闭已连接套接字，不会影响对方，他们只是对引用计数-1。
同理，需要注意，当不关闭时，任何一方都可以访问公共的套接字。这会导致在子进程中调用accpet也可以
获得返回，在父进程中也可以读/写已连接套接字。

	记住：文件是独立于任何进程的系统级资源，而socket就是一种文件。
		
================================================================================================
		
close函数会先把缓冲区内的数据发完，然后在进入关闭流程(发送FIN触发四次挥手)

不论套接字是不是阻塞的，close函数都不阻塞，立刻返回。

================================================================================================
		
（！！！） FIN 的四次挥手究竟是什么样的流程？

众所周知，FIN 分节是四次挥手 开始的标志，然而，FIN并不意味着对端立刻会给自己也回一个FIN，四次挥手
的流程如下：
				A				B
				-------FIN----->				//A 向 B 发送一个FIN,此时B读SOCKET将会读到 EOF
				<------ACK------
					.........
				<------FIN------				//B 向 A 发送一个FIN，此时A读socket将会读到EOF
				-------ACK------>
我们平时所说的四次挥手是指上面的2个 FIN 和 2个ACK，其实，在上图的 ... 位置，B还是可以向A发送数据的。

而四次挥手的潜台词是：“ 我已经没有数据要发送了，现在通过FIN告知你，你如果read读数据的话会读到
一个EOF(0), 但是你可以选择如何处理这个情况，是通过close给我也回一个 FIN ，还是先干一些别的事情
稍后再给我回FIN，当然，你也可以继续给我发数据，我依旧会读你发送来的数据。 “

可见，FIN 只是表示发送方此刻开始不再会向对方发送任何数据(这是协议栈面，不是应用层，不管发送
缓冲区是否有数据，都被清空)。

四次挥手整个流程的时间取决于应用层如何实现，是收到EOF就立刻调用close给对端一个FIN，还是先干一些
别的事情。

这里又牵扯到另一个话题，那就是在调用close的时候，close里面是先把缓冲区内的数据发出去，还是不管
缓冲区内的数据直接发送FIN。这就是 SO_LINGER 选项控制的。


（！！！）RST 分节是什么意思？和FIN有什么异同？

RST 分节 的潜台词是 ” 立刻终止当前链接， 此时此刻我不会发送数据，我也不会接收你发来的数据 “，可以
理解为 强制杀死链接。 RST 一旦触发，发送一方会立刻自我终结，接收方也会立刻终结自己，这样的话，双方
都不留任何 ”善后“ 动作的余地，发送方不会进入 TIME_WAIT 状态，双方发送的还未到达对端的网络数据包
便可能进入 错误的应用程序(复用刚才port的新应用程序)
				
				
================================================================================================
		
close 和 shutdown 的区别：

close仅仅是关闭文件描述符，即把socket套接字的引用计数-1，当且仅当套接字的引用计数为0时，才会触发
套接字的四次挥手。如果父子进程共享某些套接字，那么close动作不会影响对方使用这些共享的套接字。

如果确实想立刻关闭(触发四次挥手)某个套接字，那么可以使用shutdown函数来实现。
		
close 配合 SO_LINGER选项

close的默认动作是先立刻返回，然后让协议栈把发送缓冲区里的数据”试着“发送给对端。

如果设置了SO_LINGER选项，同时制定linger参数，则有如下几种情况：
1）l_onoff = 0 ，那么不启用SO_LINGER功能，此时close使用默认动作，即立刻返回，然后让协议栈”试着”把
   缓冲区内的数据发送给对端
2）l_onoff ！=0 ，l_linger = 0 ，close立刻返回，同时丢弃发送缓冲区中的数据，然后向对端发送一个RST，
   而不会发送FIN(即不会触发四次挥手)。RST的潜台词是 “ 没有对话，我什么都不会说，我也不会听你说的任何话 ”
		注：RST终止流程会导致双方都不会进入TIME_WAIT状态，这会导致游离在网络中的数据包可能
			进入上一个进程的化身进程中。
3）l_onoff !=0,l_liner!=0, close将阻塞一段时间(前提是套接字是阻塞的)，直到 发送缓冲区内的数据被发送完毕 
	或 l_linger设置的时间超时。 如果因为超时时间到导致close返回的话(发送缓冲区中的数据还没发完)，
	那么close返回EWOULDBLOCK，此时缓冲区内的数据被丢弃。
	如果是非阻塞套接字，那么close会立刻返回，但是close里的流程还是会正常执行。
	
================================================================================================	

close函数的 返回 、阻塞

1）默认情况下(不设置SO_LINGER选项)，close立刻返回，让协议栈把发送缓冲区中的数据”尝试发出去“，
   对应的TCP交互状态：发送完FIN，即四次挥手的第一步执行完毕
   
2）close + SO_LINGER(l_onoff=0)，同1）

3）close + SO_LINGER(l_onoff!=0,l_linger=0),close立刻返回，丢弃发送缓冲中的数据。
   对应的TCP交互状态：发送一个RST，自己不进入TIME_WAIT，对端也立刻终止
   
4）close + SO_LINGER(l_onoff!=0,l_linger!=0)
		套接字阻塞：close不会立刻返回，当且仅当缓冲区内数据发完 或者超时时间到达 时才返回。此时可以
					根据close的返回值来得知执行结果。
		
		套接字不阻塞：close立刻返回，但是内部流程还是会尝试在超时时间内发送完缓冲区内的数据，只不过
					  无法通过close返回值告知应用层。

================================================================================================	

TCP协议栈层面的传输控制分节不会进入 收发缓冲区中排队，如果本端发送FIN给对端，理论上对端只要进入
TCP层，就会立刻回一个ACK，同时把数据解包压入接收缓冲区以供应用层处理。除非数据包卡在链路层，那么
传输控制分节将可能丢失。此时发送端TCP协议栈由于未收到ACK，会进入重发流程。

================================================================================================	

（！！！）关闭连接时的异常场景

1）四次挥手流程中，服务器崩溃，四次挥手仅第一步，或者1,2两步做完了，然后服务器在还没有来及通过
   协议栈给客户端回 ACK / FIN，那么客户端将一直在TIME_WAIT状态下等待，然后呢？？？？

================================================================================================

关闭连接时，最后一部分数据的送达（下面结合 close 和 shutdown一起讨论，比较复杂）

四次挥手的时候，客户端发送完FIN并收到服务端的ACK后(如果没收到ACK，则会重发FIN，如果多次都收不到，则发送RST)，
应用数据会被压入对端的接收队列中排队，而客户端因为收到了ACK，所以认为对端已经收到了，此时对应着close函数
的返回，但是close的返回并不表示应用数据已经被服务端读取(参照上面”close函数的 返回 、阻塞“)，为了能够
让客户端知道服务端已经”读取了应用数据“(注意，不是收到，而是读取，收到的标志是对端回了ACK，ACK是协议栈回
的，只表示数据进入了接收缓冲区)。


================================================================================================

客户端connect在三次握手的第二个步骤后就会返回，而服务端的accept将在第三个步骤之后才会返回，因为此时，
socket才会从未完成队列移动到已完成队列中，这会触发accept的返回。


================================================================================================

accept返回之前服务端收到RST

有这样一种情况，当客户端通过connect发起三次握手后，客户端的connect顺利返回，同时服务端的协议栈也
给客户端回了三路握手的的最后一个分节，此时当前连接已经被排入服务端的已完成队列中。现在让服务端
暂停运行，然后在客户端立刻通过SO_LINGER选项的设置并配合close来触发一个RST，这个时候服务端便会
在accpet返回之前收到RST。不同的系统对于这种 ”已经建立链接，但是还没有给链接生成套接字描述符的
情况“，会有不同的反应：
1）有的内核会把这种情况在协议栈层面消化掉，相当于把刚才的链接从已完成队列中移除。
2）有的内核则会在服务器调用accept获取这个链接的时候报错。

	注：如果是2），那么就需要针对不同的错误码，给予合适的处理流程。

================================================================================================

（！！！）RST分节需要注意

当一个进程向某个已经收到RST的套接字执行写操作时，内核会向进程发送一个SIGPIPE信号，而该信号
的默认行为是终止进程，进程应当捕获这个信号，以免被意外终止。

（！！！）RST分节的产生
1）通过SO_LINGER和close配合产生
2）如果本端已经关闭了套接字，而对端依旧给自己发送数据，则本端的TCP协议栈会回一个RST。
3）收到来自“不存在于本端TCP协议栈中的链接”的数据时，都会回一个RST，2）便是这个情况的特例

	RST 的隐含意思是：我现在收到了来自不认识链接上的数据(可能因为自己的协议栈崩溃，自己的程序
	奔溃，自己的socket关闭而将socket链接信息移除协议栈)，我不愿意处理不认识的数据，给我发数据
	人，请你自己把这个链接从你自己的TCP协议栈中移除吧。
	
复习：close关闭会同时关闭本端的收 和 发，如果希望单独控制，可以使用shutdown来独立控制关闭收发

	（实验）：
		客户端主动close，服务端收到EOF后不关闭已连接套接字，而是继续写入一些数据，
		此时客户端应该会回一个RST给服务端。请验证。

================================================================================================

一种EOF的情况：

前面提到了，读套接字时，一旦返回值是0，则表示对端给自己发了一个FIN，FIN的发送和接收是协议栈层面
的，不收应用程序的执行流程影响，但是FIN对应的0却需要应用程序读socket才能知道，而不是内核通过
信号的方式中断应用程序的当前执行流程。这就引入一个问题，“如果应用程序阻塞在其他别的地方，那么
就没法及时调用read来得知对端给自己发了FIN，进而就没法及时给对端回FIN或者其他流程”，为了解决这个
问题，就要求应用程序需要隔一会就read一次socket一遍及时响应对端的四次挥手，因此在程序设计时，如果
有阻塞点，则需要考虑是否使用select这种可以同时监控多个阻塞文件描述符的函数来进行代码重构。

================================================================================================

一次 read 可能读到的数据量是多少？

首先read会指定想要读的数据量，其次网络数据的到达是以tcp包为单位的，如果发送端用户层的数据超过
了MSS，那么会被划分到不同的tcp包中，那么他们到达目的端就是分批次到达，如果read动作在多个批次之间
返回，那么read可能就需要多次读取才会读到原来完整数据的全貌。

================================================================================================

异步 I/O ：调用aio_read和aio_write系列动作，同时指定一个回调通知函数(其实是信号处理函数)，调用
		   aio_xxx的时候会立刻返回，但是并不说明已经读到/写入数据，而是说我已经把io动作交给内核了，
		   内核完成以后通过回调通知函数告诉我一声。
		   
信号式 I/O ：注册一个I/O可读的信号处理函数，当I/O可读/可写时，进入信号处理函数中进行读写。

	二者的异同：二者都把自己的需求委托给内核，异步io获得内核的通知是“你的工作已经完成”，而
				信号式io获得的内核通知是“你现在可以去干活了，原材料到了”

================================================================================================

select监控的套接字描述符集何时可用？

可读：1）有数据可读(接收缓冲区内的数据>=可读阈值)
	  2）收到对端发来的FIN
	  3）已完成队列中有新的连接(仅针对accept函数)
	  4）有错误(这个时候返回-1)

可写：1）有空间可写(发送缓冲区的可用空间>=可写阈值)
	  2）收到对端发来的FIN		(这里很有意思)
	  3）有错误(这个时候返回-1)
	  
异常：1）外带数据

================================================================================================

使用close的风险

假设数据从客户端连续地向服务端发送，服务端会处理这些数据然后组织新的报文应答给客户端，这就会形成一个
数据流在两个管道中流通，如果客户端在发送完数据就调用close，那么它将无法得到服务器应答的数据。此时，
我们可以使用shutdown把客户端的发送功能关闭，但是保留接收功能，shutdown会一并触发FIN，告知服务器
“自己希望结束这个链接，如果同意的话请给我回FIN，与此同时，我的接收功能依旧是开放的，你可以把
处理好的数据告诉我，我还能处理，不过我会在你给我FIN之后把接收功能也关掉”

================================================================================================

close 和 shutdown 的总结

close一次会同时关闭socket的收发功能，shutdown可以独立控制关闭哪些功能

close不会立刻触发文件关闭，同样就不保证一定触发FIN，shutdown会立刻关闭socket，同时会触发FIN

SO_LINGER选项会影响close，具体见上文。SO_LINGER不会影响shutdown

================================================================================================

SO_KEEPALIVE

默认关闭，如果两小时内tcp链接上没有任何数据交互，则一种一端的TCP协议栈就会给对端发一个保活分节，
此时会有如下三种情况：
1）如果对端回应了ACK，则双端都当做什么都没发生
2）如果对端回应了RST，则表示对端已经 崩溃且又重新启动，总之就是--> “你已经不在我TCP协议栈的缓冲区里了”
   （！）注意，应用程序重启不会出现这个情况，因为tcp协议栈内的数据还在。
3）对端没有任何反应，本端会进入重发流程，这个流程持续11分钟。如果还是没反应，则本端自我关闭套接字！！！
   对这个套接字操作将会返回-1,错误 ETIMEOUT。
   
================================================================================================

（！！！）shutdown深究

shutdown WR 选项会发送 FIN
shutdown RD 选项不会发送 FIN

================================================================================================

对端发送的FIN只能通过读套接字来获得，如果程序一致循环写套接字，那么它将无法获知对端是否给自己发了
FIN

================================================================================================

一端程序异常 可能会出现的情况

状态						对端“进程”崩溃(协议栈中还存有当前链接)			对端“主机崩溃”(协议栈已被清空)			对端主机不可达

本端TCP主动发数据			对端发起四次挥手，发送FIN，如果本段没有			本端进入超时流程						本段进入超时流程
							按原计划走四次挥手，则对端发送RST，如果
							本段继续写数据，TCP协议栈便拦截这个动作，
							告知内核给应用程序一个SIGPIPE信号。
							主动发数据意味着一直在循环/阻塞写socket，
							这个时候没法获得对端发送的FIN。
							
本段TCP主动接受数据			对端发起四次挥手，发送FIN，此时因为本端			read不到数据(应用/协议栈)				read不到任何数据(应用/协议栈)
							处于主动读socket，所以可以及时获得这个FIN，
							read系列函数返回0，再怎么处理看应用程序。
							
链接空闲，keep_alive=true	对端发送FIN，read返回0							进入保活流程							进入保活流程

链接空闲，keep_alive=false	对端发送FIN，read返回0 							无										无


================================================================================================

close 和 shutdown 汇总

shutdown ，shut_rd				本端套接字关闭读功能，清空接收缓冲区，后续来自对端的数据会被TCP
								协议栈立刻丢弃。本段套接字的写功能正常。不发送FIN
								
shutdown ，shut_wr				本段套接字关闭写功能，把现有接收缓冲区内的数据发送出去，套接字不再可写，
								本段套接字读功能正常，tcp协议栈依旧把对端的数据存入接收缓冲区。
								发送FIN。
								
close ， l_onoff=0				本段套接字关闭读写，把发送缓冲区内的数据发送给对端。套接字引用计数-1，如果
(默认)							为0，当且仅当发送缓冲区内的数据都发送出去再发送FIN，同时把接收缓冲区内的数据清空。
								函数立刻返回

close，l_onoff=1				本段套接字关闭读写，接收发送缓冲区都被清空，套接字引用计数-1，如果为0,则发送RST给对端，链接状态
	   l_linger=0				变为CLOSED，不进入TIME_WAIT。
										
close，l_onoff=1				本段套接字关闭读写，接收缓冲区数据被清空。在一定时间内没能把发送缓冲区内的数据发给对端在，则
	   l_linger！=0				close返回EWOULDBLOCK，如果超时之前发完，close返回0。最后不论如何都进入
								CLOSED状态。
								close在超时和发送完数据这两种情况下返回。
										
										
	close，l_onoff=1，l_linger=0 这种情况是最极端的，不管任何数据，直接强制关闭。
										
	（实验）：close，l_onoff=0，当且仅当把发送缓冲区内的数据都发送出去再发送FIN，是不是所有数据都获得ACK才
			  会发送FIN，还是只要发送出去而不管对端是否ACK？？？


================================================================================================

TCP的流量控制

每次交互将窗口值告知对方，这窗口值是当前接收缓冲区中空闲的空间大小。如果对端发送超过窗口值大小
的TCP包，则本端会丢弃这个包(因为没有按照大家约定的标准执行)

SYN分节中的Win窗口值是最大窗口值，即本端接收缓冲区的最大值，在后续的数据交互中，Win会动态变化以
告知对端自己最新的窗口值。

SO_RECVBUF必须在三次握手之前设置，因为三次握手的时候需要协商Win最大值，而Win最大值恰恰就是接收
缓冲区大小

================================================================================================

快速恢复算法 要求 接收/发送缓冲 的最小值 应当大于 MSS的4倍

如果使用MTU 大于1480的链路层，则需要适当将 接收/发送缓冲区扩大。

================================================================================================

发送低水位 和 接收低水位

发送低水位：当发送缓冲区内的 “空闲” 空间大于等于某个值，则套接字可写。
			（！！！）注意：不可以误认为，大于等于某个值才发送数据，发送数据始终都在进行
			
接收低水位：当接收缓冲区内有至少多个个字节，则套接字可读。
			
	（！！！）其实更好的翻译应该是 ： 接收缓冲区可写低水位  和  发送缓冲区会发送低水位
	
================================================================================================

SO_REUSEADDR

场景1）

如果父进程accpet返回后fork子进程处理已连接套接字，接着自己close已连接套接字(close关闭，程序终止)，
则父进程再次启动时便无法再次bind到原来的端口，因为端口已经被刚才的子进程占用了。

	注：当且仅当fork时可以出现多个进程绑定同一个端口的情况。如果两个完全不相干的进程
		向绑定到同一个端口，后绑定的将失败。
		
那么如何解决父进程close套接字(shutdown不行)后依旧可以在使用原来的端口，这时候就需要使用SO_REUSEADDR选项，
这个选项的设置需要在 socket之后和bind之前。

    注：这种场景下，同一个端口只有一个“监听套接字”，其他绑定到这个端口上的都是已连接套接字。
		（！！！）监听套接字可以和已连接套接字共享端口，但是要求监听套接字程序设置SO_REUSEADDR。
		下面我们将看到多个监听套接字绑定同一个端口

场景2）

如果有多个服务进程(启动监听套接字的)都想绑定同一个端口，这些进程有都在同一个机器上(共享tcp协议栈)，那么
改如何处理？
tcp不允许多个服务进程使用相同的 ip 和 port 同时监听的，但是允许这些服务进程 使用不同的ip，但是需要设置SO_REUSEADDR
所以，解决方法就是创建socket时给不同的服务程序绑定不同的 ip即可，但是由于这些服务在同一台机器上，每台机器
的网卡数量是有数量的，所以可以理解为“有几个网卡就能启动几个具有相同port不同ip的服务程序”。


场景3）

一个服务进程使用不同的ip和相同的port，创建多个监听套接字，这种情况也可以通过SO_REUSEADDR来实现，这个2）有点
相似，一个是多个服务进程，一个是单个服务进程，相同点在于他们都是用不同的ip，这也是好理解的，毕竟TCP协议栈
不关心你是哪个进程，它只关心你注册了哪些socket到自己的内存里。

场景4）
在UDP协议下，使用SO_REUSEADDR可以跨越 场景123的限制，直接捆绑相同的ip和port到多个socket上，因为UDP是
无连接的，这一般用在多播场景下。

	注意：4的特殊性仅在UDP场景下，123都在TCP场景下


================================================================================================

SO_REUSEPORT

不是所有系统都支持，且SO_REUSEADDR完全可以覆盖其功能，故不讨论


================================================================================================

受套接字是否阻塞影响的函数有：
1）输入类： read readv recv recvfrom  recvmsg
2）输出类：	write writev send sendto sendmsg
3）accept 
4）connect

	即所有 读/写 系列 ，外加 服务端的accept  和 客户端的 connect

================================================================================================

信号 的 触发会对程序执行流程产生什么影响？

默认情况下，当信号发生时，会进入信号处理函数，如果信号处理函数中没有跳转 或者 exit之类的跳转
操作，那么当信号处理函数执行完毕后，程序会返回到原来的执行位置继续执行。
但是，如果当前函数处于阻塞状态(上面提到的会阻塞套接字的函数)，那么阻塞函数会返回-1，通知赋值
errno为 EINTR , 因此阻塞状态的函数在处理返回值是需要特殊关照错误码 EINTR，一般收到以后会继续
刚才的阻塞动作。

	注：所有阻塞函数都可以被信号中断阻塞而返回-1(errno=EINTR)。

================================================================================================

使用recv 和 send 替换 read 和 write

recv 和 send 是对 read 和 write 的功能扩展。

前三个参数一样，只不过增加了一个操作标识：

MSG_DONTROUTE  :  本次操作不路由，仅只对本次操作，对比 SO_DONTROUTE 对当前socket所有报文都不允许路由

MSG_DONWAIT	：本次操作部阻塞，对比把套接字设置成非阻塞模式(默认阻塞)后，影响所有消息

MSG_OOB : 外带数据

MSG_PEEK : 仅recv 和 recvfrom 可用，可以查看缓冲区内的数据，但是不会取，所哟数据依旧在缓冲区内

MSG_WAITALL : 仅 recv 和 recvfrom 可用，当前仅当读到指定数量的数据才返回，正常情况下，读取动作
			  一旦发现接受缓冲区内有数据就读取并返回(默认接收低水位是1)。除非1）捕捉到信号；2）
			  链接被终止；3）套接字错误；这三种情况下会返回小于预期的字节数(和默认情况一样)。
			  
================================================================================================	  

使用 readv 和 wirtev 进行分散读取 和 集中写入

有时候在用户层面可能有多个线程在一并 生产/消费 发送/接收 数据，默认情况下，我们需要在各个线程处都调用
read/write 系列函数，这就显得比较分散，不好管理。

此时，可以使用readv 和 writev 来指定多个缓冲区，让所有写成只负责生产/消费数据，集中发送 和 读取并分配
的任务交给 一个 socket交互线程即可。

================================================================================================

使用 recvmsg 和 sendmsg 实现更多的功能

如果可以，使用 recvmsg  和 sendmsg将能够完成其他其他 IO的动作，就是参数设置比较麻烦。


	小结：这些io操作都需要面对阻塞非阻塞的问题，他们各自提供了特殊的功能，但是在流程执行
		  层面都是一样的。

================================================================================================

使用标准IO

标准IO是指一些文件操作相关的动作，比如getc，gets，puts，等等，这些io都有自己的
内部缓冲区，此时需要 考虑缓冲区类型  无缓冲/行缓冲/全缓冲。因此使用这类IO来进行编程时，需要
主要数据是是否暂停在IO函数的缓冲区中，如果在，那么这些数据其实还没有被送到socket的缓冲区内。

================================================================================================

要区别对待的 是  标准I  和  1）输入类： read readv recv recvfrom  recvmsg
				 标准O	和  2）输出类：	write writev send sendto sendmsg
							 
标准IO有自己的缓冲区。
read系列和write系列都没有自己的缓冲区，只需要考虑阻塞问题即可

================================================================================================

非阻塞式connect 怎么写？？？？


上面提到connect也受套接字的是否阻塞影响。默认情况下connect的阻塞时间是75s，这如果放在主线程里，那么
将是非常恐怖的，因此我们可以先设置connect为非阻塞，然后使用select来定时监控描述符的状态变化

如果让connect非阻塞，那么调用connect可能会立刻返回EINPROGRESS，此时三次握手已经在进行中，但是问题又来了，
我怎么知道三次握手是否成功，毕竟我connect不会等到三次握手成功才返回。

这里POSIX就规定了：
如果描述符可写，那么表示链接已经建立，
如果描述符可读又可写，那么表示发生了错误。
那么如果监控状态？使用select来监控即可。

如果使用非阻塞，并在select出设置超时等待时间：
1）将套接字加入select监控中
2）调用connect
3）调用select阻塞等待套接字状态的变化


	写法：16.4 P 353

注：非阻塞connect非常复杂，有很多异常需要填补，样例已经足够完善，但是在不同的系统上还是有
	移植不一致，所以还是建议使用阻塞式，然后为其创建一个线程用来避免主线程阻塞。
	
================================================================================================

（！！！）如果阻塞connect的时候发生了中断

这个时候connect会返回 EINTR ，那么我们要如何得知三次握手是否成功呢？这个时候如果再去connect，
就会返回错误EADDRINUSE表示三次握手已经在流程中，那么我们就不得不使用select来监控描述符的可读
可写情况。 当且仅当 描述符可写时，才表示链接已经建立。

================================================================================================

非阻塞式accpet 怎么写？？？？

当监听套接字上产生了已连接套接字时，监听套接字变得可读。
因此我们可以把accept监控的监听套接字设置为非阻塞，然后在select中监控其是否可读，一旦可读就对
其调用accept，此时accpet一定会成功，因为前面的select的返回已经说明其已完成队列中有数据可读。


如果可以，尽量使用阻塞时accept。

如果使用非阻塞accept，请参考 p-362


	继续  p-362

================================================================================================




























