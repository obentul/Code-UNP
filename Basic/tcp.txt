#1 - 可靠		:	每个请求，都必须有应答
     可靠基础上的重传	:	如果没有应答，那么以递增间隔进行重传，直至N次，则放弃此链路
     RTT		:	统计一个”请求+应答”共消耗了多少时间，用来做参考，每次都会统计
     排序		:	大包会被分段，每段都有序号，在接收端重新排序
     流量控制		:	在每次交互中(不管请求还是应答)，TCP头中都会携带“希望对端回给自己的报文的最大字节上限”，这个值一般是自己接受缓冲区剩余可用的
                                字节数。从缓冲区中读数据，则此值变大，向缓冲区中写数据，则此值变小；当为0时，TCP层不再接收数据(链路拥塞了)，直至有可用空间。
				这个值又叫窗口值。
     全双工		:	双端都有收/发缓冲区，自然也有配套的管理机制。


#2 - TCP的可选项
	1）	MSS	:	分段的最大字节数，即每个TCP数据段的最大字节数(segment是TCP的最小通讯单元，fragment是IP的最小通讯单元)
	2）窗口规模	:	前面的流量控制中说到了窗口值，这个窗口规模就是用来设置那个值的，在TCP头中，这个值是16位的，因此最大取值为65535。也就是说
				缓冲区最大为65535个字节，一个segment中最多65535个字节。这个值得吞吐量不是很大，可以考虑从TCP的实现层来调整TCP头中的16位
				为更大的空间，以完成高吞吐量的要求。
	3）时间戳	:	

#3 - C和S都可以主动关闭连接(close socket fd)，通常情况下，是C端关闭连接，对于HTTP而言，S端关闭的情况比较多

#4 - TCP状态转换图

#5 - TIME_WAIT态与MSL(maximum segment timelife)
	MSL默认情况下是30s~2min，处于这个状态下的C或S最多存在1min~4min
	超过MSL到达的ip fragment将被丢弃
   
#6 - TIME_WAIT状态存在的理由：1、可靠的全双工(这个不做过多解释，就是说结束的时候尽可能地等待对端告知自己结束的ACK)
			   (*)2、保证残留数据包被丢弃，因为数据包的存货时间是MSL(这个事ip层写死的)，所以很可能A发送了数据包后就关闭连接了，那么B很可能还
				 没收到数据包但是提前收到了FIN。此时B如果直接关闭的话，就会出现数据包在网络中处于"无家可归"的状态，而如果此时允许C以相同
				 与B的IP和PORT启动，那么这个数据包就会被送给C了，这样是不安全的，我们必须保证“无家可归”的数据包就“死在”网络上，而不是被
				 “冒名顶替”的C乘机拿走，所以在TIME_WAIT期间，IP+PORT组合依旧被B占用，不给别人“乘虚而入”的机会。  小结：就相当于B占着当前
				 的IP+PORT对，不再接收数据，也不让其他人使用这个IP+PORT对，以此来达到让残留尚未到达的数据包被IP层自我消灭的目的。

#7 - 端口号由TCP管理

#8 - 四元素定义一个链接   A.IP  A.PORT  B.IP B.PORT    ,因此对于监听端，同一个端口可以有N多个链接，可以想象成“神经束”状，因此不会出现监听端端口耗光的情况

#9 - 勘误：套接字！=IP+PORT, 因为 连接套接字的PORT+IP == 监听套接字的PORT+IP

#10 - 一台机器可能有多个IP，那么就可能出现对于同一个监听端口80，可以启动两个监听服务，IP1+80，IP2+80,这两个服务(或者1个进程中两个监听套接字)不会产生任何
      冲突。    “四元素定义一个链接”这个原则很重要。

#(*)11 - fork子进程处理链接的情况下，因为子进程也持有监听PORT+IP,那么如何保证新上来的请求进入了父进程PORT，而不是进入了子进程PORT ？？
	实验证明：1)如果子进程也被挂在PORT上，和父进程轮流从PORT上取连接(如果子进程调用了accept的话)
		  2)由此可见 “多个进程可以监听同一个端口”，那么端口和进程可以是“一对一，一对多，多对一，多对多”的关系
		  3)端口是“公共资源”，不和进程做任何形式的绑定

#12 - MTU值是数据链路层一次性传输的最大字节数(fragment的最大字节数)，具体的值随着接口的不同而不同，比如以太网接口，MTU=1500
		如果使用以太网接口，那么任何超过1500的IP fragment都将被切割成最大为1500的多个fragment依次传输
	IP层不论把自己的MTU设置的多大都没用，最终要取决于链路层的MTU值

	注：IP层的MTU更像是软件层面的MTU，链路层MTU更像是硬件限制的MTU，IP层通过自己设置MTU来保证自己给链路层的fragment最大为MTU个字节，但是链路层的MTU
	    会进行二次筛选，如果到来的fragment 大于自己的MTU，那么自己还再会分割一次，如果小于自己的MTU，那么就无所谓了
      
      鉴于链路是双向的，所以作为全双工通讯模式，MTU应该有两个值，这两个值可以一样，也可以不一样，因为双向的链路本身就是独立的，这两个MTU是否一样不会互相影响

#13 - ipv4可以再ip头中指定消息不分片标志位，此时如果满足分片条件，那么会报错ICMPv4

#(*)14 - 可以使用SO_SNDBUF选项来更改缓冲区的大小(收/发)。

#(*)15 - 当套接字为阻塞时(默认，也可用fcntl函数设置)，且发送缓冲区空间不足(小于write的buff尺寸/有其他未发送的数据)，此时write函数会阻塞，直到缓冲区可用。
	     这里也可以看出，发送缓冲区一次只能处理一个请求
	 write一个套接字返回成功，仅表示数据从用户控件的buffer中复制到了tcp的发送缓冲区中了，不能保证对端收到了数据

#(*)16 - 当且仅当收端给发端应答ACK，发端才能把刚才的发送的数据从发送缓冲区中清除(好低效啊！！！)	
		
		(后期引入了滑动窗口机制，来避免这种低效工作模式)

#17 - 
















