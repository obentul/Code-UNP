#1 - 可靠		:	每个请求，都必须有应答
     可靠基础上的重传	:	如果没有应答，那么以递增间隔进行重传，直至N次，则放弃此链路
     RTT		:	统计一个”请求+应答”共消耗了多少时间，用来做参考，每次都会统计
     排序		:	大包会被分段，每段都有序号，在接收端重新排序
     流量控制		:	在每次交互中(不管请求还是应答)，TCP头中都会携带“希望对端回给自己的报文的最大字节上限”，这个值一般是自己接受缓冲区剩余可用的
                                字节数。从缓冲区中读数据，则此值变大，向缓冲区中写数据，则此值变小；当为0时，TCP层不再接收数据(链路拥塞了)，直至有可用空间。
				这个值又叫窗口值。
     全双工		:	双端都有收/发缓冲区，自然也有配套的管理机制。


#2 - TCP的可选项
	1）	MSS	:	分段的最大字节数，即每个TCP数据段的最大字节数(segment是TCP的最小通讯单元，fragment是IP的最小通讯单元)
	2）窗口规模	:	前面的流量控制中说到了窗口值，这个窗口规模就是用来设置那个值的，在TCP头中，这个值是16位的，因此最大取值为65535。也就是说
				缓冲区最大为65535个字节，一个segment中最多65535个字节。这个值得吞吐量不是很大，可以考虑从TCP的实现层来调整TCP头中的16位
				为更大的空间，以完成高吞吐量的要求。
	3）时间戳	:	

#3 - C和S都可以主动关闭连接(close socket fd)，通常情况下，是C端关闭连接，对于HTTP而言，S端关闭的情况比较多

#4 - TCP状态转换图

#5 - TIME_WAIT态与MSL(maximum segment timelife)
	MSL默认情况下是30s~2min，处于这个状态下的C或S最多存在1min~4min
	超过MSL到达的ip fragment将被丢弃
   
#6 - TIME_WAIT状态存在的理由：1、可靠的全双工(这个不做过多解释，就是说结束的时候尽可能地等待对端告知自己结束的ACK)
			   (*)2、保证残留数据包被丢弃，因为数据包的存货时间是MSL(这个事ip层写死的)，所以很可能A发送了数据包后就关闭连接了，那么B很可能还
				 没收到数据包但是提前收到了FIN。此时B如果直接关闭的话，就会出现数据包在网络中处于"无家可归"的状态，而如果此时允许C以相同
				 与B的IP和PORT启动，那么这个数据包就会被送给C了，这样是不安全的，我们必须保证“无家可归”的数据包就“死在”网络上，而不是被
				 “冒名顶替”的C乘机拿走，所以在TIME_WAIT期间，IP+PORT组合依旧被B占用，不给别人“乘虚而入”的机会。  小结：就相当于B占着当前
				 的IP+PORT对，不再接收数据，也不让其他人使用这个IP+PORT对，以此来达到让残留尚未到达的数据包被IP层自我消灭的目的。

#7 - 端口号由TCP管理

#8 - 四元素定义一个链接   A.IP  A.PORT  B.IP B.PORT    ,因此对于监听端，同一个端口可以有N多个链接，可以想象成“神经束”状，因此不会出现监听端端口耗光的情况

#9 - 套接字=IP+PORT
	socket函数从当前套接字中取一个套接字描述符给申请者
	一个套接字可以有N多个套接字描述符，比如监听套接字描述符和已连接套接字描述符都关联到同一个套接字上，但是他们持有不同的描述符，单独关闭任何某个描述符
	只是把这个套接字对外开放的套接字描述符计数器-1.

#10 - 一台机器可能有多个IP，那么就可能出现对于同一个监听端口80，可以启动两个监听服务，IP1+80，IP2+80,这两个服务(或者1个进程中两个监听套接字)不会产生任何
      冲突。    “四元素定义一个链接”这个原则很重要。

#(*)11 - fork子进程处理链接的情况下，因为子进程也持有监听PORT+IP,那么如何保证新上来的请求进入了父进程PORT，而不是进入了子进程PORT ？？
	实验证明：1)如果子进程也被挂在PORT上，和父进程轮流从PORT上取连接(如果子进程调用了accept的话)
		  2)由此可见 “多个进程可以监听同一个端口”，那么端口和进程可以是“一对一，一对多，多对一，多对多”的关系
		  3)端口是“公共资源”，不和进程做任何形式的绑定

#12 - MTU值是数据链路层一次性传输的最大字节数(fragment的最大字节数)，具体的值随着接口的不同而不同，比如以太网接口，MTU=1500
		如果使用以太网接口，那么任何超过1500的IP fragment都将被切割成最大为1500的多个fragment依次传输
	IP层不论把自己的MTU设置的多大都没用，最终要取决于链路层的MTU值

	注：IP层的MTU更像是软件层面的MTU，链路层MTU更像是硬件限制的MTU，IP层通过自己设置MTU来保证自己给链路层的fragment最大为MTU个字节，但是链路层的MTU
	    会进行二次筛选，如果到来的fragment 大于自己的MTU，那么自己还再会分割一次，如果小于自己的MTU，那么就无所谓了
      
      鉴于链路是双向的，所以作为全双工通讯模式，MTU应该有两个值，这两个值可以一样，也可以不一样，因为双向的链路本身就是独立的，这两个MTU是否一样不会互相影响

#13 - ipv4可以再ip头中指定消息不分片标志位，此时如果满足分片条件，那么会报错ICMPv4

#(*)14 - 可以使用SO_SNDBUF选项来更改缓冲区的大小(收/发)。

#(*)15 - 当套接字为阻塞时(默认，也可用fcntl函数设置)，且发送缓冲区空间不足(小于write的buff尺寸/有其他未发送的数据)，此时write函数会阻塞，直到缓冲区可用。
	     这里也可以看出，发送缓冲区一次只能处理一个请求
	 write一个套接字返回成功，仅表示数据从用户控件的buffer中复制到了tcp的发送缓冲区中了，不能保证对端收到了数据

#(*)16 - 当且仅当收端给发端应答ACK，发端才能把刚才的发送的数据从发送缓冲区中清除(好低效啊！！！)	
		
		(后期引入了滑动窗口机制，来避免这种低效工作模式)

#17 - 
















