#1 - read的用法：
     again:
	while(n=read(sock_fd,buff,4096)>0)
	{
		recordbuff(buff);
		//writen(sock_fd,buff,n);	//可选，回写给对方时，可以使用writen，避免了while循环
	}
	if(n<0&&errno=EINTR)
		goto again;
	else if(n<0)
		perror("read error:");

----------------------------------------------------------------------------------------------------------------------------------------------------------

#2 - 使用ps命令查看服务端和客户端的运行状态：
	ps -o pid,ppid,tty,stat,args,wchan|grep "xxx"
	结合stat和wchan可以确定当前进程的状态。

----------------------------------------------------------------------------------------------------------------------------------------------------------
#3 - ctrl+d是终端文件的EOF符，普通文件也有EOF符号，都是用来标示已达到文件末尾

----------------------------------------------------------------------------------------------------------------------------------------------------------
#4 - 信号，也被称为软件中断
	如果信号在阻塞期间发生了一次或者多次，那么当信号被解除阻塞后(比如退出信号处理函数)，信号只会被递交一次，即默认情况下，信号是不排队的，也可以
	使用排队接口创建排队的信号，这里不讨论，具体见APUE的信号章节	

----------------------------------------------------------------------------------------------------------------------------------------------------------
#5 - 僵死状态存在的意义：为了维护子进程的信息，以便父进程知晓子进程的进程id，终止状态以及资源利用信息(CPU时间，内存使用量等等).僵尸进程会占用内核内存区
     的存储空间。

----------------------------------------------------------------------------------------------------------------------------------------------------------
#6 - 慢速系统调用可能存在被信号中断的情况，此时系统调用会返回-1，同时errno为EINTR，此时需要在处理慢速系统调用返回值得时候特别注意这种情况，一般发现
     这种情况的处理动作都是在此调用被中断的系统调用(某些操作系统有自动回复机制，但是为了可移植性考虑，建议自己检查一遍)。

	(*)注意：大部分的慢速系统调用(read,write,accept....)都可以通过在此调用来解决。
	(*)但是！connect函数不能通过在此调用来解决，一旦在此调用connect，将会立刻返回错误(因为调用connect会发出握手SYN请求，在此调用就会在此发送，这样是
	      未被TCP协议栈机制的)，此时此刻必须通过select轮询connect的第一个参数来判断connect是否成功了。
	(注：需要通过实验来证明！！！观察NJCC中是不是有这个问题)

----------------------------------------------------------------------------------------------------------------------------------------------------------

#(*)7 - 子进程并发终止，父进程并发收到SIGCHLD怎么办？
	问题复现：创建一个fork模式的服务器，创建一个客户端，此客户端循环N次与服务端建立连接。建连完成后，客户端强制终止。此时会有N个子进程同时向父进程
		  发送SIGCHLD。
	现象：由于信号的不排队机制，父进程只能处理两个子进程的终止，另外三个子进程会变成僵尸进程
	如何解决：1）对于这种并发且时差很小的情况，可以在信号处理函数中，使用waitpid代替wait：
			while(waitpid(-1,&stat,WNOHANG)>0)
	             因为子进程是同时终止的，因此waitpid循环回收即可，但是如果某2个子进程延迟了2秒钟再终止，这个方案依旧不可行
		  2）使用可排队的信号处理机制，具体见APUE的信号章节

----------------------------------------------------------------------------------------------------------------------------------------------------------
#(*)8 - 一个时间差的问题，关于accept的
	问题复现：服务端启动后，在accept之前sleep或者干别的事情去了，没有在listen之后立刻accept，而恰好在这个时间内，客户端“不玩了”，发了一个RST给服务端，
		  要求终止本次通讯。那么这个时候由于服务端在干别的事情，所以没法立刻对这个事情做出反应。
	现象：此时服务端在处理完其他事情后，一旦调用accept，便会立刻报错ECONNABORTED。
	如何解决：这种情况是由于客户端过于“心急”导致的，所以作为服务端，应该忽略这个报错，在此调用accept即可

----------------------------------------------------------------------------------------------------------------------------------------------------------
#(*)9 - FIN的触发条件？
	FIN分包的发送是由TCP来完成的，那么TCP在什么时候会触发呢？一个情况就是当前套接字的所有套接字描述符都被关闭了。还有一种情况就是使用shutdown函数

----------------------------------------------------------------------------------------------------------------------------------------------------------
#10 - 对链接状态的获取必须通过socket系列API才能获得，因此这就存在一个问题，如果就是不调用这些API(connect,bind,accept,read,write)，那么就无法“及时地”获得
      这些状态，比如我正阻塞读另一个文件，此时此刻，select和poll这样的函数就发挥作用了。
      在程序设计中，尽量避免阻塞操作某个文件描述符，尽量使用select系列函数来完成并发处理和整体监控

----------------------------------------------------------------------------------------------------------------------------------------------------------
#(*)11 - RST的触发条件？
	 ？？？

----------------------------------------------------------------------------------------------------------------------------------------------------------
#12 - 如果服务器挂了，那么客户端在向服务器请求服务的时候会收到各式各样的错误码，每种错误码对应于不同的场景，具体见unp5.14
	PS:如果我们想立刻知道服务器是否挂了，而不是通过向服务器发送消息获得返回码的方式，那么可以指定SO_KEEPALIVE选项来完成这个功能

----------------------------------------------------------------------------------------------------------------------------------------------------------
#13 - 如果服务器挂了，又重启了？那么只要客户端没指定SO_KEEPALIVE,客户端是无法感知服务端挂的

----------------------------------------------------------------------------------------------------------------------------------------------------------
#14 - 当传输的内容不是文本，而是二进制字节流的时候，C和S的字节序选择奖直接决定最终双方表达的意思是否一致。因此在流媒体传输的时候需要额外注意字节序

----------------------------------------------------------------------------------------------------------------------------------------------------------
#15 - 如下场景中可以考虑使用:
	1）同时处理多个文件描述符
	2）同时处理多个套接字
	3）同时处理监听套接字和已连接套接字
	4）同时处理TCP和UDP
	5）同时处理多个服务或者多个协议

----------------------------------------------------------------------------------------------------------------------------------------------------------
#16 - I/O模型：
	1）阻塞I/O
	2）非阻塞I/O
	3）I/O复用(select和poll)
	4）信号驱动I/O(SIGIO)
		当I/O可用时，产生SIGIO信号，然后根据系统设定，决定哪种处理方式
	5）异步I/O（aio_系列函数）
		用户把要做的I/O工作告知内核，让内核去执行，然后自己继续做自己的事，当内核执行完后，发送一个信号(用户自定义是什么信号，甚至可以使自杀信号)
		给用户用户空间，进而选择忽略，默认或者进入信号处理函数

	(*)4和5很像，都是异步的，唯一的区别就是，4是告知内核“如果可以I/O，请发信号给我”，5是告知内核“你去做什么I/O动作，并且马上去做，做完了发信号给我”

----------------------------------------------------------------------------------------------------------------------------------------------------------
#17 - 一个输入操作一般包括两个不同的阶段：
	1）等待数据准备好(由内核通过驱动程序完成)
	2）把数据从内核空间复制到用户空间(由系统调用来完成)
      类比网络I/O：
	1）数据从网络上到达内核(数据从网卡驱动到达内核)
	2）把内核空间的数据复制到用户空间(由系统调用完成)

----------------------------------------------------------------------------------------------------------------------------------------------------------
#18 - 套接字何时可读(select系列函数返回的满足条件)，满足一下四个条件之一，都可读：
	1）套接字的接受缓冲区内数据量大于某个阈值，可以使用SO_RCVLOWAT来设置这个值，默认是1(这就是为什么read一个套接字，有时候依次读不完，因为只要大于1
	   个字节，对套接字read就能成功了，所以一个消息可能陆陆续续进入接受缓冲区(因为数据是被分包传递的))
	2）接收了FIN的TCP链接
	3）套接字的已完成队列大于0
	4）套接字处理错误，此时可读，但是读到的是报错错误码

	其中1和3是读到正常的数据，因此当select返回某个套接字可读的时候，一定要判断read的返回值，并进行相应的判断处理

      
      套接字何时可写(select系列函数返回的满足条件)，满足一下四个条件之一，都可写：
	1）套接字的发送缓冲区内数据量大于某个阈值，可以使用SO_SNDLOWAT来设置这个值，默认是2048
	2）连接的写半部关闭，对这样的套接字写将产生SIGPIPE信号
	3）connect成功，或者失败
	4）套接字错误待处理，写的时候，返回的是报错错误码，而不是写入了多少字节

     
      套接字何时异常：
	略

----------------------------------------------------------------------------------------------------------------------------------------------------------
#19 - 设置SO_RCVLOWAT 和 SO_SNDLOWAT 的意义：
	如果知道了报文的最小长度，那么可以通过设置这个值来减少I/O动作的次数
	（那如果这个阈值变高以后，后续到达的数据达不到这个阈值怎么办，岂不是这些数据要死在缓冲区里？？？）
	（这里需要通过实验来模仿，首先需要模仿数据陆续到达的场景，然后拆出来一个小字节的无法满足阈值的包最后处理，观察能不能触发读取动作）

----------------------------------------------------------------------------------------------------------------------------------------------------------
#20 - 前面说了套接字可读的情况，那么映射到实际编码中，对应的就是如下三种情况：
	1）对端TCP发送数据，那么套接字是可读的，并且返回读到了多少个字节
	2）对端TCP发送FIN，那么套接字可读，返回0
	3）对端TCP发送RST，那么套接字可读，返回-1
		注：以上结果，当且仅当对套接字读的时候，才会有返回值

----------------------------------------------------------------------------------------------------------------------------------------------------------
#21 - 套接字是全双工的，读和写是分开的，因此对于C端，发送一个FIN给S，仅仅代表C端自己关闭了写功能，依旧保持读功能。

	shutdown和close的区别：
		1）close仅仅把套接字的引用计数减1，当且仅当引用计数为0的时候，此套接字才会关闭（因此多个进程同时监听一个端口时候，甚至一个进程多次打开
	           同一个套接字以获得多个套接字描述符的时候，close并不会关闭套接字）
		2）鉴于close是关闭套接字的，因此一旦关闭就是全双工两个通道都关闭，不能做到精准控制
		3）shutdown函数可以用来立刻关闭套接字全双工管道中的任意一条，因为不是通过关闭套接字描述符来达到目标，所以shutdown是立刻关闭

----------------------------------------------------------------------------------------------------------------------------------------------------------
#22 - 每个已链接socket(描述符)都有一个自己的收/发缓冲区，作为并发服务端，如果有1000个C端向服务端写数据，那么就要开辟1000个已连接socket，响应的就有1000
      个收/发缓冲区对，这还是“相当吃内存的”。比如一个缓冲区2048个字节，一对就是4M，1000个就是4G。(需要考证是否确实如此)

        (结论：实际情况确实是这样的，百万级别并发量的单机服务器，必须通过调整tcp缓冲区大小，或者扩展内核所占的内存空间，来完成并发量的承载)
        (socket收/发缓冲区使用的都是内核空间的内存，还是相当恐怖的)

----------------------------------------------------------------------------------------------------------------------------------------------------------
#23 - 避免拒绝服务攻击的简单方法：1）使用非阻塞I/O
			          2）独立单独的线程或者进程来处理已连接套接字
                                  3）对I/O操作设置一个超时

----------------------------------------------------------------------------------------------------------------------------------------------------------
#24 - poll函数的使用
	原型：int poll(struct pollfd *fdarray,unsigned long nfds,int timeout)
	描述：参数1 是一个结构体数组，定义为struct pollfd {
							int fd;		//被监听的描述符
							short events;	//被监听描述符对应的被监听事件(有一套宏)，赋值为指定的事件
							short revents;	//实际发生的事件(有一套宏)，初始值为0，poll返回后会对其进行赋值
						}
	      参数2 是数组的个数
              参数3 是poll轮询超时时间
	返回：和select一样，返回的满足条件的描述符个数
	使用：select需要通过FD_ISSET判断，poll只需要判断结构体中的revents是不是0即可，如果是0，则代表什么都没发生
	PS：如果不再关心某个fd，只需要把对应的fd置-1(因为数组一旦确定，则在内存中的结构就定死了，不能把某个结构体移出数组，所以把响应的fd置-1)

		使用数组不是很好，占内存，另外从可移植性考虑，select的通用性要由于poll

----------------------------------------------------------------------------------------------------------------------------------------------------------




















               
















