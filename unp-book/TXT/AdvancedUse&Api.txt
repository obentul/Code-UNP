TCP是字节流协议（创建SOCKT的时候指定），最小接收单元是字节
UDP是数据包协议，最小接收单元是包



#1 - syslogd使用的socket就是UNIX域socket，速度快
	(理解原理，或者学习如何使用syslogd，从而来利用到自己的项目中来)

        syslogd启动后会执行如下5步：
            1）读取配置文件/etc/syslog.conf,此配置文件指定接收到的日志如何处理，是被输出到文件中，还是输出到某个终端上，还是转发给某个远程机器的syslogd
            2）创建unix域套接字，捆绑到指定的路径上/var/run/log
            3）创建UDP套接字，绑定端口514
            4）打开/dev/log
            5）进入死循环轮询select返回值，用select监控2,3,4创建的文件描述符(/var/run/log对应的fd,514的套接字fd,/dev/log对应的fd)，一旦某个fd可读，则select
               返回可读的fd，并按照配置文件处理(这里可能是多进程处理，也可能是多线程处理，需要考证)。
               一旦受到SIGHUP信号，syslod重新读取配置文件，接着运行。
    

#2 - 套接字创建的套接字描述符，默认是阻塞的，如果某个套接字当前不可用，那么“调用”套接字的时候就会阻塞。这里的”调用“有如下四种：
     1）读出操作，包括五个函数————read、readv、recv、recvfrom、recvmsg。如果某个进程对于阻塞套接字调用上述五个操作，而套接字的读缓冲区又没有数据可读。那么
        就会睡眠，知道有数据为止。
		(注意：上面说了，只要有数据就返回，TCP又是字节流的，那么可能就只有1个字节到了缓冲区，这个时候也返回，这样就需要循环读，那么如果想等到缓冲区
                 有N个字节了再跳出睡眠，并返回。要么使用readn，要么指定MSG_WAITALL标志)
     		(对于TCP，只要缓冲区有一个字节可读，都不会阻塞；对于UDP，只要缓冲区有一个包可读，都不会阻塞)
		(如果套接字描述符是非阻塞的，)
	(疑问：阻塞不阻塞到底是针对套接字而言？还是针对套接字描述符而言？实验：父子进程都打开某个套接字，父进程设置描述符为非阻塞，然后同时读，看子进程是否阻塞)
	(猜测：子进程阻塞？那么阻塞非阻塞是针对套接字描述符而言；子进程不阻塞？那么阻塞非阻塞是针对套接字而言)
	(结论：阻塞非阻塞是针对套接字“描述符”的，从使用fcntl这个函数就能看的出来)
     2）写入操作，包括五个函数————write、writev、send、sendto、sendmsg。
	在tcp场景下，如果缓冲区又1000个字节，已经被占了500个，然后现在要写进入600个，那么内核会从600个里面拿500写进去，然后会阻塞，需要再次调用write把剩下的100个写进去
     3）accept函数
     4）tcp的connect函数


#3 - 守护进程的相关知识，见/Code-C/ProcessRelationShip + Daemon


#4 - inetd是守护进程管理器，很多网络服务程序都被注册在inetd中，因为这些网络服务程序的执行流程都比较相似，都是通过监听某个套接字来与外界通讯，都是守护进程运行，都在
     收到新连接后fork子进程来处理，父进程继续监听套接字。所以就出现inetd超级服务程序来将具有相同流程的守护进程归集到一起。（不怎么常用），配置文件为/etc/inetd.conf


#5 - 在对套接字描述符的操作上存在I/O的超时问题需要解决，因为如果套接字中没有数据，那么不能总是阻塞读/写，而应该给出超时信号，目前可用的是如下三种方法：
        1）在read/write套接字之前，设置alarm来注册一个时钟，当read/write返回时，立刻关闭此时钟。这个方法的思路是使用信号进行管理。
        2）使用select/poll/epoll这些异步I/O函数，这些函数本身自带定时功能，当指定时间内没有任何可读/写的套接字出现时，则会返回一个错误码。
            （而且相比于1，这种方法能同时监控多个套接字）
        3）使用SO_RCVTIMEO/SO_SNDTIMEO选项，这个选项是后期为了解决超时问题添加的，不过只针对套接字描述符，不针对普通描述符，有局限性
        
        
#6 - 我们在使用connect函数的时候，有时需要设置超时:
       int connect(int sockfd, const struct sockaddr *addr,socklen_t addrlen);
     connect的最大超时时间是75秒，因此如果scokfd设置成阻塞状态，那么当网络对端不回应本端发出的SYNC时，本端将最长等待75秒，这就很变态了，因此有必要设置一个超时处理机制
     可以使用#5中三种方法中的任意一种。
    （如果套接字是非阻塞的，那么就不会出现这个超时问题，此时一旦对端在n微秒内没有回SYNC，connect将立刻返回一个错误码，ps，默认情况下套接字描述符都是阻塞的）
    （有关connect的超时复现：随便创建一个客户端，connect一个无法到达的套接字(ip+port),程序将卡在connect，知道75秒超时返回错误码）
    
#7 - 相较于read和wirte的简单粗暴，系统提供功能更强大的recv和send函数
        ssize_t recv(int sockfd, void *buf, size_t len, int flags);
        ssize_t send(int sockfd, const void *buf, size_t len, int flags);
     这两个函数前三个参数和read/write 一样，只是多了一个flags，这个flags功能较强：

            MSG_DONTROUTE   如果对端是本地网络不需要路由，那么绕过路由协议                                      send可用
            MSG_DONTWAIT    针对本次操作，非阻塞                                                                recv/send都可用
                            (即使是阻塞套接字描述符，本次操作也是非阻塞的，不会改变套接字原阻塞标志位)          
            MSG_OOB         发送/接收外带数据                                                                   recv/send都可用
                            (什么是外带数据，见TCP的包头)
            MSG_PEEK        只窥看数据，不取数据，数据依旧存放在套接字缓冲区中，不会被删除                      recv可用
            MSG_WAITALL     等待收到指定len(第三个参数)个数据后才返回                                           recv可用

        注意：这里要说一下MSG_WAITALL，这个标志加上以后，就可以替代readn函数了，但是在如下三种情况下，即使没收到len个数据，还是会返回，所以还是要判断返回值：
                1）被信号打断，此时errno为EINTR（所有慢速系统调用都有这个问题）
                2）连接被终止
                3）套接字发生错误（有哪些？？？）
        不论什么函数，读套接字就是慢速系统调用，总是会有问题，只是比read少返回几次（一个报文过大时，可能存在于两个TCP包中，不是一次性到达，所以落在套接字接收缓冲区中是由时差
        的，这造成了业务上想读一个报文，但是read需要返回两次或者多次才能获得完整）

#8 - recvmsg和sendmsg，这两个函数比recv和send多出来一个功能——————内核可以设置flags，其他使用上都一样。ps，recv和send的flags不能被内核操作，即驱动程序不能使用recv和send。

#9 - 分散读(readv) 和 集中写(writev)
        分散读：把套接字描述符/普通描述符中的数据，读到多个buffer中。比如有char buffer[10][10],10*10的二维数组，那么分散读的时候，会优先填充buffer[0],填满10个字节后，再填
                buffer[1],加入有55个字符，那么0-4是填充满的，5中有5个字节，6-9则是空的。这个函数用来解决大报文，小缓冲区的情况。
        集中写：参照分散读的机制，集中写就是把多个buffer中的数据按照顺序归纳到一块，然后通过只调用一次系统调用把数据写入指定描述符。
                (这个函数可以用来避免Nagle算法的发生)

#10 - Nagle算法：Nagle算法是以他的发明人John Nagle的名字命名的，它用于自动连接许多的小缓冲器消息；这一过程（称为nagling）通过减少必须发送包的个数来增加网络软件系统的效率。
        （如果我想发送两个数据包，一个是4字节，一个是8字节，那么正常发送的话，是两个TCP包，而这两个包都要加上TCP头和IP头，这样带宽利用率就很低，于是乎小包会被组成大包）

        规则：
            （1）如果包长度达到MSS，则允许发送；
            （2）如果该包含有FIN，则允许发送；
            （3）设置了TCP_NODELAY选项，则允许发送；
            （4）未设置TCP_CORK选项时，若所有发出去的小数据包（包长度小于MSS）均被确认，则允许发送；
            （5）上述条件都未满足，但发生了超时（一般为200ms），则立即发送。
    
        注意：默认情况下，Nagle算法是打开的，可以通过在创建套接字时指定TCP_NODELAY来关闭这个功能。

        小结：1）Nagle是用来解决带宽利用率低的问题，但是会引入实时性差的问题(因为小包会等待其他小包，直到这些包的尺寸和大于MSS，才会被发送出去)。
              2）Nagle是传输控制层的(TCP),其针对的是TCP包，而不是IP包。
        
        举例：客户端和服务端互相发送的数据都是100ms发送一个‘k’，那么对端收到的应当是“kk”的tcp包，因为200ms时超时了，即使是2个字节的小包也要发送。如果我们设置了TCP_NODELAY，
              那么对端收到的就是‘k’的tcp包，因为即使是一个字节的小包，也要立刻打上tcp包头包尾发送出去。

#11 - recvmsg 和 sendmsg  （14.5）
        这两个函数比较全能，但是只针对套接字描述符。因此我们在使用时，“如果面向所有描述符，那么使用read和write；如果仅针对套接字描述符，那么使用recvmsg和sendmsg”
            具体参考man page

#12 - 辅助数据 （14.6）
        针对recvmsg和sendmsg有许多高级功能，这些功能大多是针对TCP/IP层的，比如指定下一跳ip地址，指定跳限，指定路由头等等。
        比较高级，如有需求，可以细致了解

#13 - MSG_PEEK会被阻塞，因此需要配合MSG_DONTWAIT使用，或者指定套接字描述符为非阻塞
        (可能只是想偷看下，结果没东西，就被勾在那阻塞住了)

#(*)14 - select函数使用注意：如果设置超时时间，那么在select返回时，这个存放超时时间的结构体内的数据会变成随即，当再次使用select的时候，需要重新设置一次
        因为大部分情况下select是被while(1)包裹的，如果时间结构体变成了0，那么这是就会出现不停调用select的情况，造成cpu使用率过高的问题


#15 - kqueue,高级轮询，内核级别，是select，pselect，poll，epoll的高级版本，但是限定于特定版本的linux发行版，可移植性略差，看情况，如果某个系统急需性能优化，那么可以考虑
        放弃移植性，上kqueue。

--------------------------------------------------------------------------------------------------------------------

#16 - 









